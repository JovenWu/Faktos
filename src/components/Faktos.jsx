/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef, useState } from 'react'
import { useGLTF } from '@react-three/drei'

function Faktos(props) {
  const { nodes, materials } = useGLTF('/Faktos2.glb')
  
  // Create hover states for each letter
  const [hoverF, setHoverF] = useState(false)
  const [hoverA, setHoverA] = useState(false)
  const [hoverK, setHoverK] = useState(false)
  const [hoverT, setHoverT] = useState(false)
  const [hoverO, setHoverO] = useState(false)
  const [hoverS, setHoverS] = useState(false)
  
  // Scale factor when hovered
  const hoverScale = 1.1
  
  // Create materials with transition effects
  const createTransitionMaterial = () => {
    const material = materials['Material.004'].clone()
    material.userData.transition = true
    return material
  }
  
  // Transition materials
  const transitionMaterialF = createTransitionMaterial()
  const transitionMaterialA = createTransitionMaterial()
  const transitionMaterialK = createTransitionMaterial()
  const transitionMaterialT = createTransitionMaterial()
  const transitionMaterialO = createTransitionMaterial()
  const transitionMaterialS = createTransitionMaterial()
  
  return (
    <group {...props} dispose={null}>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Background001.geometry}
        material={materials['Material.003']}
        position={[0, -1.067, 0]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.A001.geometry}
        material={transitionMaterialA}
        position={[-0.925, -0.065, -0.097]}
        rotation={[1.584, 0, 0]}
        scale={hoverA ? hoverScale : 1}
        onPointerOver={() => setHoverA(true)}
        onPointerOut={() => setHoverA(false)}
        onUpdate={(self) => {
          if (self.userData.currentScale !== self.scale.x) {
            self.scale.lerp({x: hoverA ? hoverScale : 1, y: hoverA ? hoverScale : 1, z: hoverA ? hoverScale : 1}, 0.1)
            self.userData.currentScale = self.scale.x
          }
        }}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.F001.geometry}
        material={transitionMaterialF}
        position={[-1.438, 0.03, -0.095]}
        rotation={[1.584, 0, 0]}
        scale={hoverF ? hoverScale : 1}
        onPointerOver={() => setHoverF(true)}
        onPointerOut={() => setHoverF(false)}
        onUpdate={(self) => {
          if (self.userData.currentScale !== self.scale.x) {
            self.scale.lerp({x: hoverF ? hoverScale : 1, y: hoverF ? hoverScale : 1, z: hoverF ? hoverScale : 1}, 0.1)
            self.userData.currentScale = self.scale.x
          }
        }}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.K001.geometry}
        material={transitionMaterialK}
        position={[-0.221, 0.025, -0.095]}
        rotation={[1.584, 0, 0]}
        scale={hoverK ? hoverScale : 1}
        onPointerOver={() => setHoverK(true)}
        onPointerOut={() => setHoverK(false)}
        onUpdate={(self) => {
          if (self.userData.currentScale !== self.scale.x) {
            self.scale.lerp({x: hoverK ? hoverScale : 1, y: hoverK ? hoverScale : 1, z: hoverK ? hoverScale : 1}, 0.1)
            self.userData.currentScale = self.scale.x
          }
        }}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.O001.geometry}
        material={transitionMaterialO}
        position={[0.92, 0.039, -0.095]}
        rotation={[1.584, 0, 0]}
        scale={hoverO ? hoverScale : 1}
        onPointerOver={() => setHoverO(true)}
        onPointerOut={() => setHoverO(false)}
        onUpdate={(self) => {
          if (self.userData.currentScale !== self.scale.x) {
            self.scale.lerp({x: hoverO ? hoverScale : 1, y: hoverO ? hoverScale : 1, z: hoverO ? hoverScale : 1}, 0.1)
            self.userData.currentScale = self.scale.x
          }
        }}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.S001.geometry}
        material={transitionMaterialS}
        position={[1.567, 0.009, -0.096]}
        rotation={[1.584, 0, 0]}
        scale={hoverS ? hoverScale : 1}
        onPointerOver={() => setHoverS(true)}
        onPointerOut={() => setHoverS(false)}
        onUpdate={(self) => {
          if (self.userData.currentScale !== self.scale.x) {
            self.scale.lerp({x: hoverS ? hoverScale : 1, y: hoverS ? hoverScale : 1, z: hoverS ? hoverScale : 1}, 0.1)
            self.userData.currentScale = self.scale.x
          }
        }}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.T001.geometry}
        material={transitionMaterialT}
        position={[0.312, 0.063, -0.095]}
        rotation={[1.584, 0, 0]}
        scale={hoverT ? hoverScale : 1}
        onPointerOver={() => setHoverT(true)}
        onPointerOut={() => setHoverT(false)}
        onUpdate={(self) => {
          if (self.userData.currentScale !== self.scale.x) {
            self.scale.lerp({x: hoverT ? hoverScale : 1, y: hoverT ? hoverScale : 1, z: hoverT ? hoverScale : 1}, 0.1)
            self.userData.currentScale = self.scale.x
          }
        }}
      />
    </group>
  )
}

useGLTF.preload('/Faktos2.glb')

export default Faktos