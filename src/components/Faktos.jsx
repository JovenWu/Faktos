/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef, useState, useEffect, useMemo } from 'react'
import { useGLTF } from '@react-three/drei'
import { useFrame } from '@react-three/fiber'

function Faktos(props) {
  const { nodes, materials } = useGLTF('/Faktos2.glb')
  const [isScrolling, setIsScrolling] = useState(false)
  
  // Create hover states for each letter
  const [hoverF, setHoverF] = useState(false)
  const [hoverA, setHoverA] = useState(false)
  const [hoverK, setHoverK] = useState(false)
  const [hoverT, setHoverT] = useState(false)
  const [hoverO, setHoverO] = useState(false)
  const [hoverS, setHoverS] = useState(false)
  
  // Scale factor when hovered
  const hoverScale = 1.1
  
  // Add scroll detection
  useEffect(() => {
    const handleScroll = () => {
      setIsScrolling(true)
      clearTimeout(window.scrollTimeout)
      window.scrollTimeout = setTimeout(() => {
        setIsScrolling(false)
      }, 150)
    }
    
    window.addEventListener('scroll', handleScroll)
    return () => window.removeEventListener('scroll', handleScroll)
  }, [])
  
  // Create materials with transition effects - memoized for performance
  const transitionMaterials = useMemo(() => {
    const createTransitionMaterial = () => {
      const material = materials['Material.004'].clone()
      material.userData.transition = true
      return material
    }
    
    return {
      F: createTransitionMaterial(),
      A: createTransitionMaterial(),
      K: createTransitionMaterial(),
      T: createTransitionMaterial(),
      O: createTransitionMaterial(),
      S: createTransitionMaterial()
    }
  }, [materials])
  
  // Optimized update function
  const updateMesh = (self, hover) => {
    if (isScrolling) return // Skip animations during scroll
    
    if (self.userData.currentScale !== self.scale.x) {
      const targetScale = hover ? hoverScale : 1
      self.scale.lerp({x: targetScale, y: targetScale, z: targetScale}, 0.1)
      self.userData.currentScale = self.scale.x
    }
  }
  
  // Group ref for optimizing the entire group when scrolling
  const groupRef = useRef()
  
  // Use frame to handle global updates for performance
  useFrame(() => {
    if (groupRef.current && isScrolling) {
      // Reduce shadow quality during scrolling
      groupRef.current.traverse((obj) => {
        if (obj.isMesh) {
          if (!obj.userData.originalCastShadow) {
            obj.userData.originalCastShadow = obj.castShadow
          }
          obj.castShadow = false
        }
      })
    } else if (groupRef.current && !isScrolling) {
      // Restore shadow quality when not scrolling
      groupRef.current.traverse((obj) => {
        if (obj.isMesh && obj.userData.originalCastShadow !== undefined) {
          obj.castShadow = obj.userData.originalCastShadow
        }
      })
    }
  })
  
  // Cleanup function for memory management
  useEffect(() => {
    return () => {
      // Clean up materials to prevent memory leaks
      Object.values(transitionMaterials).forEach(material => {
        material.dispose()
      })
    }
  }, [transitionMaterials])

  return (
    <group {...props} dispose={null} ref={groupRef}>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Background001.geometry}
        material={materials['Material.003']}
        position={[0, -1.067, 0]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.A001.geometry}
        material={transitionMaterials.A}
        position={[-0.925, -0.065, -0.097]}
        rotation={[1.584, 0, 0]}
        scale={hoverA ? hoverScale : 1}
        onPointerOver={() => !isScrolling && setHoverA(true)}
        onPointerOut={() => !isScrolling && setHoverA(false)}
        onUpdate={(self) => updateMesh(self, hoverA)}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.F001.geometry}
        material={transitionMaterials.F}
        position={[-1.438, 0.03, -0.095]}
        rotation={[1.584, 0, 0]}
        scale={hoverF ? hoverScale : 1}
        onPointerOver={() => !isScrolling && setHoverF(true)}
        onPointerOut={() => !isScrolling && setHoverF(false)}
        onUpdate={(self) => updateMesh(self, hoverF)}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.K001.geometry}
        material={transitionMaterials.K}
        position={[-0.221, 0.025, -0.095]}
        rotation={[1.584, 0, 0]}
        scale={hoverK ? hoverScale : 1}
        onPointerOver={() => !isScrolling && setHoverK(true)}
        onPointerOut={() => !isScrolling && setHoverK(false)}
        onUpdate={(self) => updateMesh(self, hoverK)}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.O001.geometry}
        material={transitionMaterials.O}
        position={[0.92, 0.039, -0.095]}
        rotation={[1.584, 0, 0]}
        scale={hoverO ? hoverScale : 1}
        onPointerOver={() => !isScrolling && setHoverO(true)}
        onPointerOut={() => !isScrolling && setHoverO(false)}
        onUpdate={(self) => updateMesh(self, hoverO)}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.S001.geometry}
        material={transitionMaterials.S}
        position={[1.567, 0.009, -0.096]}
        rotation={[1.584, 0, 0]}
        scale={hoverS ? hoverScale : 1}
        onPointerOver={() => !isScrolling && setHoverS(true)}
        onPointerOut={() => !isScrolling && setHoverS(false)}
        onUpdate={(self) => updateMesh(self, hoverS)}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.T001.geometry}
        material={transitionMaterials.T}
        position={[0.312, 0.063, -0.095]}
        rotation={[1.584, 0, 0]}
        scale={hoverT ? hoverScale : 1}
        onPointerOver={() => !isScrolling && setHoverT(true)}
        onPointerOut={() => !isScrolling && setHoverT(false)}
        onUpdate={(self) => updateMesh(self, hoverT)}
      />
    </group>
  )
}

// Optimize loading by using preload with priority
useGLTF.preload('/Faktos2.glb', { priority: 1 })

export default Faktos